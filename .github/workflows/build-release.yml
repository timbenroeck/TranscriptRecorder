name: Build and Release

on:
  push:
    tags:
      - 'v*'  # Triggers on version tags like v1.0.0
  workflow_dispatch:  # Allows manual triggering

permissions:
  contents: write  # Required to create releases

jobs:
  build:
    runs-on: macos-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.13'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip "setuptools<81"
          pip install -r requirements.txt
          pip install py2app
      
      - name: Get version
        id: version
        run: |
          VERSION=$(python -c "from version import __version__; print(__version__)")
          echo "version=$VERSION" >> $GITHUB_OUTPUT

      # =============================================================
      # CODE SIGNING: Import certificate into a temporary keychain
      # =============================================================
      - name: Import Code Signing Certificate
        env:
          MACOS_CERTIFICATE: ${{ secrets.MACOS_CERTIFICATE }}
          MACOS_CERTIFICATE_PWD: ${{ secrets.MACOS_CERTIFICATE_PWD }}
          KEYCHAIN_PWD: ${{ secrets.KEYCHAIN_PWD }}
        run: |
          # Decode the certificate from base64
          echo "$MACOS_CERTIFICATE" | base64 --decode > certificate.p12

          # Create a temporary keychain
          security create-keychain -p "$KEYCHAIN_PWD" build.keychain
          security default-keychain -s build.keychain
          security unlock-keychain -p "$KEYCHAIN_PWD" build.keychain

          # Set keychain timeout to 20 minutes (enough for the build)
          security set-keychain-settings -t 1200 -u build.keychain

          # Import the certificate into the keychain
          security import certificate.p12 \
            -k build.keychain \
            -P "$MACOS_CERTIFICATE_PWD" \
            -T /usr/bin/codesign

          # Allow codesign to access the keychain without UI prompt
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PWD" build.keychain

          # Add the keychain to the search list
          security list-keychains -d user -s build.keychain login.keychain

          # Clean up the certificate file
          rm certificate.p12

          # Verify the identity is available
          echo "Available signing identities:"
          security find-identity -v -p codesigning build.keychain

      - name: Build application
        run: |
          python setup_py2app.py py2app

      # =============================================================
      # CODE SIGNING: Sign the .app bundle
      # =============================================================
      - name: Sign Application
        run: |
          APP_PATH="dist/Transcript Recorder.app"
          ENTITLEMENTS="entitlements.plist"

          # Resolve the full signing identity from the keychain
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')
          echo "Signing with identity: $SIGNING_IDENTITY"

          if [ -z "$SIGNING_IDENTITY" ]; then
            echo "ERROR: No Developer ID Application identity found in keychain"
            security find-identity -v -p codesigning build.keychain
            exit 1
          fi

          # Sign all .so files (Python extensions)
          echo "Signing .so files..."
          find "$APP_PATH" -name "*.so" -exec \
              codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$SIGNING_IDENTITY" {} \;

          # Sign all .dylib files
          echo "Signing .dylib files..."
          find "$APP_PATH" -name "*.dylib" -exec \
              codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$SIGNING_IDENTITY" {} \;

          # Sign all frameworks (recursive â€” py2app places Qt6 frameworks in Resources/lib/)
          # Qt6 frameworks from pip wheels have non-standard bundle structure, so we
          # must sign the inner binaries explicitly before signing .framework dirs.
          echo "Signing framework binaries..."
          find "$APP_PATH" -path "*.framework/Versions/*/[A-Z]*" -type f -perm +111 ! -name "*.plist" ! -path "*/_CodeSignature/*" | while IFS= read -r fw_bin; do
              echo "  Signing $(basename "$fw_bin")..."
              codesign --force --options runtime --timestamp \
                  --entitlements "$ENTITLEMENTS" \
                  --sign "$SIGNING_IDENTITY" "$fw_bin"
          done
          echo "Signing framework bundles..."
          find "$APP_PATH" -name "*.framework" -type d | while IFS= read -r framework; do
              case "$framework" in */Versions/*|*/_CodeSignature/*) continue ;; esac
              echo "  Signing $(basename "$framework")..."
              codesign --force --options runtime --timestamp \
                  --entitlements "$ENTITLEMENTS" \
                  --sign "$SIGNING_IDENTITY" "$framework"
          done

          # Sign all executables in MacOS/
          echo "Signing executables in Contents/MacOS/..."
          for exec_file in "$APP_PATH"/Contents/MacOS/*; do
              if [ -f "$exec_file" ]; then
                  echo "  Signing $(basename "$exec_file")..."
                  codesign --force --options runtime --timestamp \
                      --entitlements "$ENTITLEMENTS" \
                      --sign "$SIGNING_IDENTITY" "$exec_file"
              fi
          done

          # Sign the entire .app bundle
          echo "Signing .app bundle..."
          codesign --force --options runtime --timestamp \
              --entitlements "$ENTITLEMENTS" \
              --sign "$SIGNING_IDENTITY" "$APP_PATH"

          # Verify
          echo "Verifying signature..."
          codesign --verify --deep --strict --verbose=2 "$APP_PATH"

      - name: Create DMG
        run: |
          APP_NAME="Transcript Recorder"
          DMG_NAME="TranscriptRecorder-${{ steps.version.outputs.version }}.dmg"
          
          # Create a temporary directory for DMG contents
          mkdir -p dmg_contents
          cp -R "dist/$APP_NAME.app" dmg_contents/
          
          # Create Applications symlink
          ln -s /Applications dmg_contents/Applications
          
          # Create DMG
          hdiutil create -volname "$APP_NAME" \
            -srcfolder dmg_contents \
            -ov -format UDZO \
            "dist/$DMG_NAME"
          
          # Clean up
          rm -rf dmg_contents

      # =============================================================
      # CODE SIGNING: Sign the DMG
      # =============================================================
      - name: Sign DMG
        run: |
          DMG_PATH="dist/TranscriptRecorder-${{ steps.version.outputs.version }}.dmg"
          SIGNING_IDENTITY=$(security find-identity -v -p codesigning build.keychain | grep "Developer ID Application" | head -1 | sed 's/.*"\(.*\)".*/\1/')

          codesign --force --timestamp \
              --sign "$SIGNING_IDENTITY" "$DMG_PATH"

          codesign --verify --verbose=2 "$DMG_PATH"

      # =============================================================
      # NOTARIZATION: Submit to Apple and staple the ticket
      # =============================================================
      - name: Notarize DMG
        env:
          APPLE_ID: ${{ secrets.APPLE_ID }}
          APPLE_ID_PASSWORD: ${{ secrets.APPLE_ID_PASSWORD }}
          APPLE_TEAM_ID: ${{ secrets.APPLE_TEAM_ID }}
        run: |
          DMG_PATH="dist/TranscriptRecorder-${{ steps.version.outputs.version }}.dmg"

          echo "Submitting for notarization..."
          xcrun notarytool submit "$DMG_PATH" \
            --apple-id "$APPLE_ID" \
            --password "$APPLE_ID_PASSWORD" \
            --team-id "$APPLE_TEAM_ID" \
            --wait \
            --timeout 30m

          echo "Stapling notarization ticket to DMG..."
          xcrun stapler staple "$DMG_PATH"

          echo "Verifying notarization..."
          spctl --assess --type open --context context:primary-signature --verbose=2 "$DMG_PATH"

      # =============================================================
      # CLEANUP: Remove the temporary keychain
      # =============================================================
      - name: Clean Up Keychain
        if: always()
        run: |
          security delete-keychain build.keychain 2>/dev/null || true

      - name: Upload artifacts
        uses: actions/upload-artifact@v4
        with:
          name: TranscriptRecorder-${{ steps.version.outputs.version }}
          path: |
            dist/*.dmg
      
      - name: Create Release
        if: startsWith(github.ref, 'refs/tags/')
        uses: softprops/action-gh-release@v1
        with:
          files: dist/*.dmg
          generate_release_notes: true
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
